"""
Custom LaTeX parser builder for easyMathSolver
Uses the custom LaTeX.g4 grammar file instead of SymPy's default one.
"""
import os
import subprocess
import glob

here = os.path.dirname(__file__)
grammar_file = os.path.abspath(os.path.join(here, "LaTeX.g4"))
dir_latex_antlr = os.path.join(here, "_antlr")

header = '''\
# *** GENERATED BY easyMathSolver, DO NOT EDIT BY HAND ***
#
# Generated from custom LaTeX.g4 (modified from SymPy's version)
#     Original latex2sympy is licensed under the MIT license
#     https://github.com/augustt198/latex2sympy/blob/master/LICENSE.txt
#
# Generated with antlr4
#    antlr4 is licensed under the BSD-3-Clause License
#    https://github.com/antlr/antlr4/blob/master/LICENSE.txt
'''


def check_antlr_version():
    """Check if antlr4 is available"""
    try:
        output = subprocess.check_output(["antlr4"]).decode('utf-8').split("\n")[0]
        print(f"Found antlr4: {output}")
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("WARNING: The 'antlr4' command line tool is not installed.")
        print("Install it with: pip install antlr4-tools")
        return False


def build_custom_parser(output_dir=dir_latex_antlr, force=False):
    """
    Build the LaTeX parser from the custom grammar file.

    Args:
        output_dir: Directory to output generated parser files
        force: If True, rebuild even if files exist
    """
    # Check if already built
    if not force and os.path.exists(os.path.join(output_dir, "latexlexer.py")):
        print(f"Custom LaTeX parser already built in {output_dir}")
        return True

    if not os.path.exists(grammar_file):
        raise FileNotFoundError(f"Custom grammar file not found: {grammar_file}")

    if not check_antlr_version():
        print("Skipping parser build - antlr4 not available")
        print("The parser may have been pre-built, attempting to use existing files...")
        return False

    print(f"Building custom LaTeX parser from {grammar_file}")
    print(f"Output directory: {output_dir}")

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Create __init__.py with header
    with open(os.path.join(output_dir, "__init__.py"), "w+") as fp:
        fp.write(header)

    # Run antlr4 to generate parser
    args = [
        "antlr4",
        grammar_file,
        "-o", output_dir,
        "-no-visitor",
        "-no-listener",
    ]

    print(f"Running: {' '.join(args)}")
    subprocess.check_output(args, cwd=output_dir)

    print("Applying headers and cleaning up generated files...")

    # Clean up and rename generated files
    for path in (glob.glob(os.path.join(output_dir, "LaTeX*.*")) or
                 glob.glob(os.path.join(output_dir, "latex*.*"))):

        # Remove .interp and .tokens files
        if not path.endswith(".py"):
            os.unlink(path)
            continue

        # Rename to lowercase and add header
        new_path = os.path.join(output_dir, os.path.basename(path).lower())
        with open(path, 'r') as f:
            lines = [line.rstrip() + '\n' for line in f]

        os.unlink(path)

        with open(new_path, "w") as out_file:
            # Skip existing headers
            offset = 0
            while lines[offset].startswith('#'):
                offset += 1

            # Write custom header
            out_file.write(header)

            # Write the rest of the file
            for line in lines[offset:]:
                out_file.write(line)

    print(f"Custom LaTeX parser built successfully in {output_dir}")
    return True


def ensure_custom_parser():
    """
    Ensure the custom parser is built and available.
    Call this at import time to make sure the parser is ready.
    """
    try:
        build_custom_parser(force=False)
    except Exception as e:
        print(f"Warning: Could not build custom parser: {e}")
        print("Will attempt to use pre-built files if available")


if __name__ == "__main__":
    # Allow manual rebuild with: python _build_custom_latex_parser.py
    build_custom_parser(force=True)
